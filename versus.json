{"transactions":{"art_collection":"\nimport NonFungibleToken from 0xNonFungibleToken\nimport Art from 0xArt\n\n//This transaction will prepare the art collection\ntransaction() {\n    prepare(account: AuthAccount) {\n        account.save<@NonFungibleToken.Collection>(<- Art.createEmptyCollection(), to: Art.CollectionStoragePath)\n        account.link<&{Art.CollectionPublic}>(Art.CollectionPublicPath, target: Art.CollectionStoragePath)\n\t\t\t\taccount.link<&{NonFungibleToken.CollectionPublic}>(Art.CollectionPublicPathStandard, target: Art.CollectionStoragePath)\n    }\n\n}\n\n","bid":"import FungibleToken from 0xFungibleToken\nimport NonFungibleToken from 0xNonFungibleToken\nimport Versus from 0xVersus\nimport Art from 0xArt\n\n// Transaction to make a bid in a marketplace for the given dropId and auctionId\ntransaction(marketplace: Address, dropId: UInt64, auctionId: UInt64, bidAmount: UFix64) {\n    // reference to the buyer's NFT collection where they\n    // will store the bought NFT\n\n    let vaultCap: Capability<&{FungibleToken.Receiver}>\n    let collectionCap: Capability<&{Art.CollectionPublic}> \n    let versusCap: Capability<&{Versus.PublicDrop}>\n    let temporaryVault: @FungibleToken.Vault\n\n    prepare(account: AuthAccount) {\n\n        // get the references to the buyer's Vault and NFT Collection receiver\n        var collectionCap = account.getCapability<&{Art.CollectionPublic}>(Art.CollectionPublicPath)\n\n        // if collection is not created yet we make it.\n        if !collectionCap.check() {\n\t\t\t\t\t  account.unlink(Art.CollectionPublicPath)\n\t\t\t\t\t  destroy <- account.load<@AnyResource>(from:Art.CollectionStoragePath)\n            // store an empty NFT Collection in account storage\n            account.save<@NonFungibleToken.Collection>(<- Art.createEmptyCollection(), to: Art.CollectionStoragePath)\n\n            // publish a capability to the Collection in storage\n            account.link<&{Art.CollectionPublic}>(Art.CollectionPublicPath, target: Art.CollectionStoragePath)\n        }\n\n        self.collectionCap=collectionCap\n        \n        self.vaultCap = account.getCapability<&{FungibleToken.Receiver}>(/public/flowTokenReceiver)\n                   \n        let vaultRef = account.borrow<&FungibleToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Could not borrow owner's Vault reference\")\n\n        let seller = getAccount(marketplace)\n        self.versusCap = seller.getCapability<&{Versus.PublicDrop}>(Versus.CollectionPublicPath)\n        let currentBid=self.versusCap.borrow()!.currentBidForUser(dropId: dropId, auctionId: auctionId, address: account.address)\n        //if your capability is the leader you only have to send in the difference\n\n        // withdraw tokens from the buyer's Vault\n        self.temporaryVault <- vaultRef.withdraw(amount: bidAmount - currentBid)\n    }\n\n    execute {\n        self.versusCap.borrow()!.placeBid(dropId: dropId, auctionId: auctionId, bidTokens: <- self.temporaryVault, vaultCap: self.vaultCap, collectionCap: self.collectionCap)\n    }\n}\n \n","clock":"import Versus from 0xVersus\n\ntransaction(clock: UFix64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet adminClient:  &Versus.Admin = account.borrow<&Versus.Admin>(from: Versus.VersusAdminStoragePath) ?? panic(\"could not load versus admin\")\n\t\tadminClient.advanceClock(clock)\n\n\t}\n}\n","destroy_content":"import Versus from 0xVersus\n//This transaction will destroy a versus drop using the admin client\ntransaction(id: UInt64) {\n    let client: &Versus.Admin\n    prepare(account: AuthAccount) {\n        self.client = account.borrow<&Versus.Admin>(from: Versus.VersusAdminStoragePath) ?? panic(\"could not load versus admin\")\n    }\n\n    execute {\n        let contentCollection=self.client.getContent()\n\t\tlet drop <- dropCollection.drops[id]  <- nil\n\t\tdestroy drop\n\t}\n  }\n\n","destroy_versus":"import Versus from 0xVersus\n//This transaction will destroy a versus drop using the admin client\ntransaction(id: UInt64) {\n\tlet client: &Versus.Admin\n\tprepare(account: AuthAccount) {\n\t\tself.client = account.borrow<&Versus.Admin>(from: Versus.VersusAdminStoragePath) ?? panic(\"could not load versus admin\")\n\t}\n\n\texecute {\n\t\tlet dropCollection=self.client.getDropCollection()\n\t\tdestroy dropCollection.withdraw(id)\n\t}\n}\n\n","drop":"import FungibleToken from 0xFungibleToken\nimport NonFungibleToken from 0xNonFungibleToken\nimport Versus from 0xVersus\n\n//This transaction will setup a drop in a versus auction\ntransaction(\n    artist: Address, \n    startPrice: UFix64, \n    startTime: UFix64,\n    artistName: String, \n    artName: String,\n    description: String, \n    editions: UInt64,\n    minimumBidIncrement: UFix64, \n    minimumBidUniqueIncrement:UFix64,\n    duration:UFix64,\n    extensionOnLateBid:UFix64,\n    type: String, \n    artistCut: UFix64,\n    minterCut: UFix64\n\n    ) {\n\n\n    let client: &Versus.Admin\n    let artistWallet: Capability<&{FungibleToken.Receiver}>\n    let content: String\n\n    prepare(account: AuthAccount) {\n\n        let path = /storage/upload\n        self.content= account.load<String>(from: path) ?? panic(\"could not load content\")\n        self.client = account.borrow<&Versus.Admin>(from: Versus.VersusAdminStoragePath) ?? panic(\"could not load versus admin\")\n        self.artistWallet=  getAccount(artist).getCapability<&{FungibleToken.Receiver}>(/public/flowTokenReceiver)\n    }\n    \n    execute {\n\n        let art <-  self.client.mintArt(\n            artist: artist,\n            artistName: artistName,\n            artName: artName,\n            content:self.content,\n            description: description, \n\t\t\t\t\t\ttype: type, \n\t\t\t\t\t\tartistCut: artistCut, \n\t\t\t\t\t \tminterCut:minterCut)\n\n        self.client.createDrop(\n           nft:  <- art,\n           editions: editions,\n           minimumBidIncrement: minimumBidIncrement,\n           minimumBidUniqueIncrement: minimumBidUniqueIncrement,\n           startTime: startTime,\n           startPrice: startPrice,\n           vaultCap: self.artistWallet,\n           duration: duration,\n           extensionOnLateBid: extensionOnLateBid \n       )\n    }\n}\n\n\n","drop_single":"import FungibleToken from 0xFungibleToken\nimport NonFungibleToken from 0xNonFungibleToken\nimport Versus from 0xVersus\nimport Art from 0xArt\n\n//This transaction will setup a drop in a versus auction\ntransaction(\n    artist: Address, \n\t\tminter: Address,\n    startPrice: UFix64, \n    startTime: UFix64,\n    artistName: String, \n    artName: String,\n    description: String, \n\t\tipfsHash:String,\n    editions: UInt64,\n    minimumBidIncrement: UFix64, \n    minimumBidUniqueIncrement:UFix64,\n    duration:UFix64,\n    extensionOnLateBid:UFix64,\n    type: String, \n    artistCut: UFix64,\n    minterCut: UFix64\n    ) {\n\n\n    let client: &Versus.Admin\n    let artistWallet: Capability<&{FungibleToken.Receiver}>\n\n    prepare(account: AuthAccount) {\n      self.client = account.borrow<&Versus.Admin>(from: Versus.VersusAdminStoragePath) ?? panic(\"could not load versus admin\")\n      self.artistWallet=  getAccount(artist).getCapability<&{FungibleToken.Receiver}>(/public/flowTokenReceiver)\n    }\n\n  execute {\n\n\n    let art <-  self.client.mintArt(\n        artist: artist,\n        artistName: artistName,\n        artName: artName,\n        content:ipfsHash,\n        description: description, \n        type: type, \n        artistCut: artistCut, \n        minterCut:minterCut)\n\n       self.client.createDrop(\n          nft:  <- art,\n          editions: editions,\n          minimumBidIncrement: minimumBidIncrement,\n          minimumBidUniqueIncrement: minimumBidUniqueIncrement,\n          startTime: startTime,\n          startPrice: startPrice,\n          vaultCap: self.artistWallet,\n          duration: duration,\n          extensionOnLateBid: extensionOnLateBid \n          )\n  }\n}\n\n\n","dutchAuction":"import FungibleToken from 0xFungibleToken\nimport NonFungibleToken from 0xNonFungibleToken\nimport Versus from 0xVersus\nimport Art from 0xArt\n\n//This transaction will setup a drop in a versus auction\ntransaction(\n    artist: Address, \n    startPrice: UFix64, \n    startTime: UFix64,\n    artistName: String, \n    artName: String,\n    description: String, \n    editions: UInt64,\n    floorPrice: UFix64, \n    decreasePriceFactor:UFix64,\n\t\tdecreasePriceAmount:UFix64,\n    tickDuration:UFix64,\n    artistCut: UFix64,\n    minterCut: UFix64\n    ) {\n\n\n    let client: &Versus.Admin\n    let artistWallet: Capability<&{FungibleToken.Receiver}>\n\t\tlet artistNFTCap: Capability<&{NonFungibleToken.Receiver}>\n\t\tlet royaltyVaultCap: Capability<&{FungibleToken.Receiver}>\n    let content: String\n\n    prepare(account: AuthAccount) {\n        let path = /storage/upload\n        self.content= account.load<String>(from: path) ?? panic(\"could not load content\")\n        self.client = account.borrow<&Versus.Admin>(from: Versus.VersusAdminStoragePath) ?? panic(\"could not load versus admin\")\n        self.artistWallet=  getAccount(artist).getCapability<&{FungibleToken.Receiver}>(/public/flowTokenReceiver)\n\t\t\t\t//TODO this needs to be linked before somehow\n\t\t\t\tself.artistNFTCap=  getAccount(artist).getCapability<&{NonFungibleToken.Receiver}>(Art.CollectionPublicPathStandard)\n\t\t\t  self.royaltyVaultCap= account.getCapability<&{FungibleToken.Receiver}>(/public/flowTokenReceiver)\n    }\n    \n    execute {\n\n\t\t\tvar nftMap : @{UInt64:NonFungibleToken.NFT} <- {}\n\t\t\tvar i =(0 as UInt64)\n\n\t\t\t//I use a string:string here so that we can add other information and are not bound to a speicify NFTs type of metadata\n\t\t\tvar metadata: { String:String}={}\n\t\t\twhile i < editions {\n\t\t\t\tlet art <-  self.client.mintArt(\n            artist: artist,\n            artistName: artistName,\n            artName: artName,\n            content:self.content,\n            description: description, \n\t\t\t\t\t\ttype: \"type\", \n\t\t\t\t\t\tartistCut: artistCut, \n\t\t\t\t\t \tminterCut:minterCut)\n\n\t\t\t\t\t\tif i == 0 {\n\t\t\t\t\t\t\t  let artData=art.metadata\n\t\t\t\t\t\t\t\tmetadata[\"nftType\"] = art.getType().identifier\n\t\t\t\t\t\t\t\tmetadata[\"name\"] = artData.name\n\t\t\t\t\t\t\t\tmetadata[\"artist\"] = artData.artist\n\t\t\t\t\t\t\t\tmetadata[\"artistAddress\"] = artData.artistAddress.toString()\n\t\t\t\t\t\t\t\tmetadata[\"description\"] = artData.description\n\t\t\t\t\t\t\t\tmetadata[\"type\"] = artData.type\n\t\t\t\t\t\t\t\tmetadata[\"contentId\"] = art.contentId?.toString() ?? \"\"\n\t\t\t\t\t\t\t\tmetadata[\"url\"] = art.url ?? \"\"\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnftMap[art.id] <-! art\n\t\t\t\t\t\ti=i+1\n\t\t\t}\n\t\t\tself.client.createDutchAuction(\n\t\t\t\tnfts: <- nftMap,\n\t\t\t\tmetadata: metadata,\n\t\t\t\tstartAt: startTime,\n\t\t\t\tstartPrice: startPrice,\n\t\t\t\tfloorPrice: floorPrice,\n\t\t\t\tdecreasePriceFactor: decreasePriceFactor,\n\t\t\t\tdecreasePriceAmount: decreasePriceAmount,\n\t\t\t\ttickDuration: tickDuration,\n\t\t\t\townerVaultCap: self.artistWallet,\n\t\t\t\townerNFTCap: self.artistNFTCap,\n\t\t\t\troyaltyVaultCap: self.royaltyVaultCap,\n\t\t\t\troyaltyPercentage: minterCut)\n    }\n}\n\n\n","dutchAuctionTick":"import Versus from 0xVersus\n\n//This transaction will setup a drop in a versus auction\ntransaction(id: UInt64){\n\tlet client: &Versus.Admin\n\tprepare(account: AuthAccount) {\n\t\tself.client = account.borrow<&Versus.Admin>(from: Versus.VersusAdminStoragePath) ?? panic(\"could not load versus admin\")\n\t}\n\n\texecute {\n\t\tself.client.tickDutchAuction(id)\n\t}\n}\n","dutchBid":"import FungibleToken from 0xFungibleToken\nimport NonFungibleToken from 0xNonFungibleToken\nimport Versus from 0xVersus\nimport DutchAuction from 0xDutchAuction\nimport Art from 0xArt\n\n// Transaction to make a bid in a marketplace for the given dropId and auctionId\ntransaction(marketplace: Address, id: UInt64, bidAmount: UFix64) {\n\t// reference to the buyer's NFT collection where they\n\t// will store the bought NFT\n\n\tlet vaultCap: Capability<&{FungibleToken.Receiver}>\n\tlet collectionCap: Capability<&{NonFungibleToken.Receiver}> \n\tlet dutchAuctionCap: Capability<&DutchAuction.BidCollection{DutchAuction.BidCollectionPublic}>\n\tlet temporaryVault: @FungibleToken.Vault\n\n\tprepare(account: AuthAccount) {\n\n\t\t// get the references to the buyer's Vault and NFT Collection receiver\n\t\tlet collectionCap=  account.getCapability<&{NonFungibleToken.Receiver}>(Art.CollectionPublicPathStandard)\n\n\t\t// if collection is not created yet we make it.\n\t\tif !collectionCap.check() {\n\t\t\taccount.unlink(Art.CollectionPublicPathStandard)\n\t\t\taccount.unlink(Art.CollectionPublicPath)\n\t\t\tdestroy <- account.load<@AnyResource>(from:Art.CollectionStoragePath)\n\t\t\t// store an empty NFT Collection in account storage\n\t\t\taccount.save<@NonFungibleToken.Collection>(<- Art.createEmptyCollection(), to: Art.CollectionStoragePath)\n\n\t\t\t// publish a capability to the Collection in storage\n\t\t\taccount.link<&{Art.CollectionPublic}>(Art.CollectionPublicPath, target: Art.CollectionStoragePath)\n\n\t\t\t//publish the standard link\n\t\t\taccount.link<&{NonFungibleToken.Receiver}>(Art.CollectionPublicPathStandard, target: Art.CollectionStoragePath)\n\t\t}\n\n\t\tlet bidCap=account.getCapability<&DutchAuction.BidCollection{DutchAuction.BidCollectionPublic}>(DutchAuction.BidCollectionPublicPath)\n\t\tif ! bidCap.check() {\n\n\t\t\taccount.unlink(DutchAuction.BidCollectionPublicPath)\n\t\t\tdestroy <- account.load<@AnyResource>(from:DutchAuction.BidCollectionStoragePath)\n\n\t\t\tlet collection <- DutchAuction.createEmptyBidCollection()\n\t\t\taccount.save(<- collection, to: DutchAuction.BidCollectionStoragePath)\n\t\t\taccount.link<&DutchAuction.BidCollection{DutchAuction.BidCollectionPublic}>(DutchAuction.BidCollectionPublicPath, target: DutchAuction.BidCollectionStoragePath)\n\t\t}\n\n\t\tself.dutchAuctionCap=bidCap\n\t\tself.collectionCap=collectionCap\n\n\t\tself.vaultCap = account.getCapability<&{FungibleToken.Receiver}>(/public/flowTokenReceiver)\n\n\t\tlet vaultRef = account.borrow<&FungibleToken.Vault>(from: /storage/flowTokenVault) ?? panic(\"Could not borrow owner's Vault reference\")\n\n\t\tself.temporaryVault <- vaultRef.withdraw(amount: bidAmount)\n\t}\n\n\texecute {\n\t\tself.dutchAuctionCap.borrow()!.bid(marketplace: marketplace, id: id, vault: <- self.temporaryVault, vaultCap: self.vaultCap, nftCap: self.collectionCap)\n\t}\n}\n\n","dutchBidCancel":"import DutchAuction from 0xDutchAuction\n\n// Transaction to cancel a dutch auction bid\ntransaction(id: UInt64) {\n\n\tlet dutchAuction: &DutchAuction.BidCollection\n\n\tprepare(account: AuthAccount) {\n\n\t\tself.dutchAuction=account.borrow<&DutchAuction.BidCollection>(from: DutchAuction.BidCollectionStoragePath) ?? panic(\"Could not borrow bid collection\")\n\t}\n\n\texecute {\n\t\tself.dutchAuction.cancelBid(id)\n\t}\n\n\tpost {\n\t\t!self.dutchAuction.getIds().contains(id) : \"Should not contain bid\"\n\t}\n}\n\n","dutchBidIncrease":"import FungibleToken from 0xFungibleToken\nimport DutchAuction from 0xDutchAuction\n\n// Transaction to increase a bid\ntransaction(id: UInt64, bidAmount: UFix64) {\n\n\tlet dutchAuction: &DutchAuction.BidCollection\n\tlet temporaryVault: @FungibleToken.Vault\n\n\tprepare(account: AuthAccount) {\n\n\t\tself.dutchAuction=account.borrow<&DutchAuction.BidCollection>(from: DutchAuction.BidCollectionStoragePath) ?? panic(\"Could not borrow bid collection\")\n\n\t\tlet vaultRef = account.borrow<&FungibleToken.Vault>(from: /storage/flowTokenVault) ?? panic(\"Could not borrow owner's Vault reference\")\n\n\t\tself.temporaryVault <- vaultRef.withdraw(amount: bidAmount)\n\t}\n\n\texecute {\n\t\tself.dutchAuction.increaseBid(id, vault: <- self.temporaryVault)\n\t}\n}\n\n","marketplace":"import Art from 0xArt\nimport Marketplace from 0xMarketplace\nimport FungibleToken from 0xFungibleToken\nimport NonFungibleToken from 0xNonFungibleToken\n\n//Transaction to make a bid in a marketplace for the given dropId and auctionId\ntransaction(marketplace: Address, tokenId: UInt64, amount: UFix64) {\n\t// reference to the buyer's NFT collection where they\n\t// will store the bought NFT\n\n\tlet vaultCap: Capability<&{FungibleToken.Receiver}>\n\tlet collectionCap: Capability<&{Art.CollectionPublic}> \n\t// Vault that will hold the tokens that will be used\n\t// to buy the NFT\n\tlet temporaryVault: @FungibleToken.Vault\n\n\tprepare(account: AuthAccount) {\n\n\t\t// get the references to the buyer's Vault and NFT Collection receiver\n\t\tvar collectionCap = account.getCapability<&{Art.CollectionPublic}>(Art.CollectionPublicPath)\n\n\t\t// if collection is not created yet we make it.\n\t\tif !collectionCap.check() {\n\t\t\taccount.unlink(Art.CollectionPublicPath)\n\t\t\tdestroy <- account.load<@AnyResource>(from:Art.CollectionStoragePath)\n\n\t\t\t// store an empty NFT Collection in account storage\n\t\t\taccount.save<@NonFungibleToken.Collection>(<- Art.createEmptyCollection(), to: Art.CollectionStoragePath)\n\n\t\t\t// publish a capability to the Collection in storage\n\t\t\taccount.link<&{Art.CollectionPublic}>(Art.CollectionPublicPath, target: Art.CollectionStoragePath)\n\t\t}\n\n\t\tself.collectionCap=collectionCap\n\n\t\tself.vaultCap = account.getCapability<&{FungibleToken.Receiver}>(/public/flowTokenReceiver)\n\n\t\tlet vaultRef = account.borrow<&FungibleToken.Vault>(from: /storage/flowTokenVault)\n\t\t?? panic(\"Could not borrow owner's Vault reference\")\n\n\t\t// withdraw tokens from the buyer's Vault\n\t\tself.temporaryVault <- vaultRef.withdraw(amount: amount)\n\t}\n\n\texecute {\n\t\t// get the read-only account storage of the seller\n\t\tlet seller = getAccount(marketplace)\n\n\t\tlet marketplace= seller.getCapability(Marketplace.CollectionPublicPath).borrow<&{Marketplace.SalePublic}>()\n\t\t?? panic(\"Could not borrow seller's sale reference\")\n\n\t\tmarketplace.purchase(tokenID: tokenId, recipientCap:self.collectionCap, buyTokens: <- self.temporaryVault)\n\t}\n}\n\n","mint_art":"\nimport Versus from 0xVersus\nimport Art from 0xArt\n\n//mint an art and add it to a users collection\ntransaction(\n    artist: Address,\n    artistName: String, \n    artName: String, \n    description: String,\n\t  target:Address,\n    type: String,\n    artistCut: UFix64,\n    minterCut: UFix64\n\t) {\n\n    let artistCollection: Capability<&{Art.CollectionPublic}>\n    let client: &Versus.Admin\n\t\tlet content: String\n\n    prepare(account: AuthAccount) {\n        let path = /storage/upload\n        self.content= account.load<String>(from: path) ?? panic(\"could not load content\")\n \n        self.client = account.borrow<&Versus.Admin>(from: Versus.VersusAdminStoragePath) ?? panic(\"could not load versus admin\")\n        self.artistCollection= getAccount(target).getCapability<&{Art.CollectionPublic}>(Art.CollectionPublicPath)\n    }\n\n    execute {\n\t\t\tlet art <-  self.client.mintArt(artist: artist, artistName: artistName, artName: artName, content:self.content, description: description, type:type, artistCut: artistCut, minterCut:minterCut)\n        self.artistCollection.borrow()!.deposit(token: <- art)\n    }\n}\n\n","mint_art_e":"import Versus from 0xVersus\nimport Art from 0xArt\n\n//Transaction to mint Art and edition art and deploy to all addresses\ntransaction(\n    artist: Address,\n    artistName: String, \n    artName: String, \n    description: String,\n\t\ttype: String, \n\t\tartistCut: UFix64,\n\t\tminterCut: UFix64,\n    addresses: [Address]) {\n\n    let client: &Versus.Admin\n    let content: String\n\n    prepare(account: AuthAccount) {\n\n        let path = /storage/upload\n        self.content= account.load<String>(from: path) ?? panic(\"could not load content\")\n        self.client = account.borrow<&Versus.Admin>(from: Versus.VersusAdminStoragePath) ?? panic(\"could not load versus admin\")\n    }\n\n    execute {\n\t\t\tlet art <-  self.client.mintArt(artist: artist, artistName: artistName, artName: artName, content:self.content, description: description, type: type, artistCut:artistCut, minterCut:minterCut)\n        self.client.editionAndDepositArt(art: &art as &Art.NFT, to: addresses)\n        destroy art\n    }\n}\n\n","mint_edition":"import NonFungibleToken from 0xNonFungibleToken\nimport Art from 0xArt\nimport Versus from 0xVersus\n\n//transaction to create an edition of an nft in admins collection and send it to a user\ntransaction(\n    user: Address,\n    original:Address,\n    artId: UInt64,\n    edition: UInt64,\n    maxEdition: UInt64) {\n\n    let client: &Versus.Admin\n    let nftCollection: &NonFungibleToken.Collection\n    prepare(account: AuthAccount) {\n        self.client = account.borrow<&Versus.Admin>(from: Versus.VersusAdminStoragePath) ?? panic(\"could not load versus admin\")\n        self.nftCollection =account.borrow<&NonFungibleToken.Collection>(from: Art.CollectionStoragePath)!\n    }\n\n    execute {\n\n          let art <- self.nftCollection.withdraw(withdrawID: artId) as! @Art.NFT\n          let newArt <- self.client.editionArt(art: &art as &Art.NFT, edition:edition, maxEdition:maxEdition)\n\n          let userCollection : &{Art.CollectionPublic} = getAccount(user).getCapability<&{Art.CollectionPublic}>(Art.CollectionPublicPath).borrow()!\n          userCollection.deposit(token: <- newArt)\n\n          let originalCollection : &{Art.CollectionPublic} = getAccount(original).getCapability<&{Art.CollectionPublic}>(Art.CollectionPublicPath).borrow()!\n          originalCollection.deposit(token: <- art)\n    }\n}\n\n","mint_tokens":"\nimport FungibleToken from 0xFungibleToken\nimport FlowToken from 0xFlowToken\n\ntransaction(recipient: Address, amount: UFix64) {\n    let tokenAdmin: &FlowToken.Administrator\n    let tokenReceiver: &{FungibleToken.Receiver}\n\n    prepare(signer: AuthAccount) {\n\n        self.tokenAdmin = signer\n            .borrow<&FlowToken.Administrator>(from: /storage/flowTokenAdmin)\n            ?? panic(\"Signer is not the token admin\")\n\n        self.tokenReceiver = getAccount(recipient)\n            .getCapability(/public/flowTokenReceiver)\n            .borrow<&{FungibleToken.Receiver}>()\n            ?? panic(\"Unable to borrow receiver reference\")\n    }\n\n    execute {\n        let minter <- self.tokenAdmin.createNewMinter(allowedAmount: amount)\n        let mintedVault <- minter.mintTokens(amount: amount)\n\n        self.tokenReceiver.deposit(from: <-mintedVault)\n\n        destroy minter\n    }\n}\n","move_art":"\nimport NonFungibleToken from 0xNonFungibleToken\nimport Art from 0xArt\n\n//Transaction to move a NFT art from the signers collection to another collection\ntransaction(address:Address, artID: UInt64) {\n\n  let nftCollection: &NonFungibleToken.Collection\n\n  prepare(account: AuthAccount) {\n    self.nftCollection =account.borrow<&NonFungibleToken.Collection>(from: Art.CollectionStoragePath)!\n  }\n\n  execute {\n      let versusCollection : &{Art.CollectionPublic} = getAccount(address).getCapability<&{Art.CollectionPublic}>(Art.CollectionPublicPath).borrow()!\n      let art <- self.nftCollection.withdraw(withdrawID:artID)\n      versusCollection.deposit(token: <- art)\n  }\n}\n","profile":"import FungibleToken from 0xFungibleToken\nimport FUSD from 0xFUSD\nimport FlowToken from 0xFlowToken\nimport NonFungibleToken from 0xNonFungibleToken\nimport Art from 0xArt\nimport Versus from 0xVersus\nimport Profile from 0xProfile\nimport Marketplace from 0xMarketplace\n\ntransaction(name: String, description: String, allowStoringFollowers: Bool) {\n  prepare(acct: AuthAccount) {\n\n    let profile <-Profile.createUser(name:name, description: description, allowStoringFollowers:allowStoringFollowers, tags:[\"versus\"])\n\n    //adding existing flowToken wallet\n    let flowReceiver= acct.getCapability<&{FungibleToken.Receiver}>(/public/flowTokenReceiver)\n    let flowBalance= acct.getCapability<&{FungibleToken.Balance}>(/public/flowTokenBalance)\n    let flow=acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)!\n    let flowWallet= Profile.Wallet(name:\"Flow\", receiver: flowReceiver, balance: flowBalance, accept:flow.getType(), tags: [\"flow\"])\n    profile.addWallet(flowWallet)\n\n\n    //Add exising FUSD or create a new one and add it\n    let fusdReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/fusdReceiver)\n    if !fusdReceiver.check() {\n      let fusd <- FUSD.createEmptyVault()\n      let fusdType=fusd.getType()\n      acct.save(<- fusd, to: /storage/fusdVault)\n      acct.link<&FUSD.Vault{FungibleToken.Receiver}>( /public/fusdReceiver, target: /storage/fusdVault)\n      acct.link<&FUSD.Vault{FungibleToken.Balance}>( /public/fusdBalance, target: /storage/fusdVault)\n    }\n    let fusdWallet=Profile.Wallet(\n        name:\"FUSD\", \n        receiver:fusdReceiver,\n        balance:acct.getCapability<&{FungibleToken.Balance}>(/public/fusdBalance),\n        accept: fusdType,\n        tags: [\"fusd\", \"stablecoin\"]\n    )\n    profile.addWallet(fusdWallet)\n\n\n    //Create versus art collection if it does not exist and add it\n    let artCollectionCap=acct.getCapability<&{Art.CollectionPublic}>(Art.CollectionPublicPath)\n    if !artCollectionCap.check() {\n      acct.save<@NonFungibleToken.Collection>(<- Art.createEmptyCollection(), to: Art.CollectionStoragePath)\n      acct.link<&{Art.CollectionPublic}>(Art.CollectionPublicPath, target: Art.CollectionStoragePath)\n    }\n    profile.addCollection(Profile.ResourceCollection( \n        name: \"VersusArt\", \n        collection:artCollectionCap, \n        type: Type<&{Art.CollectionPublic}>(),\n        tags: [\"versus\", \"nft\"]))\n\n    let marketplaceCap = acct.getCapability<&{Marketplace.SalePublic}>(Marketplace.CollectionPublicPath)\n    if !marketplaceCap.check() {\n      let sale <- Marketplace.createSaleCollection(ownerVault: flowReceiver)\n      acct.save<@Marketplace.SaleCollection>(<- sale, to:Marketplace.CollectionStoragePath)\n      acct.link<&{Marketplace.SalePublic}>(Marketplace.CollectionPublicPath, target: Marketplace.CollectionStoragePath)\n    }\n    profile.addCollection(Profile.ResourceCollection(\n        \"VersusMarketplace\", \n        marketplaceCap, \n        Type<&{Marketplace.SalePublic}>(),\n        [\"versus\", \"marketplace\"]))\n\n\n    acct.save(<-profile, to: Profile.storagePath)\n    acct.link<&Profile.User{Profile.Public}>(Profile.publicPath, target: Profile.storagePath)\n  }\n}\n\n","settle":"import Versus from 0xVersus\n\n//Transaction to settle/finish off an auction. Has to be signed by the owner of the versus marketplace\ntransaction(dropId: UInt64) {\n\n    let client: &Versus.Admin\n    prepare(account: AuthAccount) {\n        self.client = account.borrow<&Versus.Admin>(from: Versus.VersusAdminStoragePath) ?? panic(\"could not load versus admin\")\n    }\n\n    execute {\n        self.client.settle(dropId)\n    }\n}\n \n","setup_marketplace_with_art":"import Marketplace from 0xMarketplace\nimport Art from 0xArt\nimport FungibleToken from 0xFungibleToken\n\n//this transaction will setup an newly minted item for sale\ntransaction(\n    artId: UInt64\n    price: UFix64) {\n\n    let artCollection:&Art.Collection\n    let marketplace: &Marketplace.SaleCollection\n\n    prepare(account: AuthAccount) {\n\n\n        let marketplaceCap = account.getCapability<&{Marketplace.SalePublic}>(Marketplace.CollectionPublicPath)\n        // if sale collection is not created yet we make it.\n        if !marketplaceCap.check() {\n             let wallet=  account.getCapability<&{FungibleToken.Receiver}>(/public/flowTokenReceiver)\n             let sale <- Marketplace.createSaleCollection(ownerVault: wallet)\n\n\t\t\t\t\t\taccount.unlink(Marketplace.CollectionPublicPath)\n\t\t\t\t\t\tdestroy <- account.load<@AnyResource>(from:Marketplace.CollectionStoragePath)\n\n            // store an empty NFT Collection in account storage\n            account.save<@Marketplace.SaleCollection>(<- sale, to:Marketplace.CollectionStoragePath)\n\n            // publish a capability to the Collection in storage\n            account.link<&{Marketplace.SalePublic}>(Marketplace.CollectionPublicPath, target: Marketplace.CollectionStoragePath)\n        }\n\n        self.marketplace=account.borrow<&Marketplace.SaleCollection>(from: Marketplace.CollectionStoragePath)!\n        self.artCollection= account.borrow<&Art.Collection>(from: Art.CollectionStoragePath)!\n    }\n\n    execute {\n        let art <- self.artCollection.withdraw(withdrawID: artId) as! @Art.NFT\n        self.marketplace.listForSale(token: <- art, price: 5.0)\n        self.marketplace.changePrice(tokenID: artId, newPrice: price)\n    }\n}\n\n","tick":"import Versus from 0xVersus\n\n/*\nSimulate that the clock is running\n */\ntransaction(dropID: UInt64) {\n    prepare(account: AuthAccount) {    \n      let block=getCurrentBlock()\n      if let versus = account.getCapability(Versus.CollectionPublicPath).borrow<&{Versus.PublicDrop}>() {\n          let versusStatus=versus.getStatus(dropId: dropID)\n          log(\"currentBlock=\".concat(block.height.toString()).concat( \" currentTime=\").concat(block.timestamp.toString()).concat( \" endTime=\").concat(versusStatus.endTime.toString()).concat(\" timeRemaining=\").concat(versusStatus.timeRemaining.toString()))\n      }\n  }\n}\n","transfer_flow":"import FungibleToken from 0xFungibleToken\nimport FlowToken from 0xFlowToken\n\n//This transactions transfers flow on testnet from one account to another\ntransaction(amount: UFix64, to: Address) {\n  let sentVault: @FungibleToken.Vault\n\n  prepare(signer: AuthAccount) {\n\n    let vaultRef = signer.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n      ?? panic(\"Could not borrow reference to the owner's Vault!\")\n\n    self.sentVault <- vaultRef.withdraw(amount: amount)\n  }\n\n  execute {\n    let recipient = getAccount(to)\n\n    let receiverRef = recipient.getCapability(/public/flowTokenReceiver)!.borrow<&{FungibleToken.Receiver}>()\n      ?? panic(\"Could not borrow receiver reference to the recipient's Vault\")\n\n    receiverRef.deposit(from: <-self.sentVault)\n  }\n}\n","transfer_flow_versus":"import FungibleToken from 0xFungibleToken\nimport FlowToken from 0xFlowToken\nimport Versus from 0xVersus\n\n//This transactions transfers flow on from versus to another user\ntransaction(amount: UFix64, to: Address) {\n  let sentVault: @FungibleToken.Vault\n\n  prepare(signer: AuthAccount) {\n    let client = signer.borrow<&Versus.Admin>(from: Versus.VersusAdminStoragePath) ?? panic(\"could not load versus admin\")\n    self.sentVault <- client.getFlowWallet().withdraw(amount: amount)\n  }\n\n  execute {\n    let recipient = getAccount(to)\n    let receiverRef = recipient.getCapability(/public/flowTokenReceiver)!.borrow<&{FungibleToken.Receiver}>()\n      ?? panic(\"Could not borrow receiver reference to the recipient's Vault\")\n\n    receiverRef.deposit(from: <-self.sentVault)\n  }\n}\n","upload":"transaction(part: String) {\n    prepare(signer: AuthAccount) {\n        let path = /storage/upload\n        let existing = signer.load<String>(from: path) ?? \"\"\n        signer.save(existing.concat(part), to: path)\n    }\n}\n","versus1":"import FungibleToken from 0xFungibleToken\nimport NonFungibleToken from 0xNonFungibleToken\nimport Content from 0xContent\nimport Art from 0xArt\nimport Versus from 0xVersus\nimport Auction from 0xAuction\n\n//this transaction is run as the account that will host and own the marketplace to set up the \n//versusAdmin client and create the empty content and art collection\ntransaction() {\n\n\tprepare(account: AuthAccount) {\n\n\n\t\tif account.getCapability(Versus.VersusAdminPublicPath).check<&AnyResource>() {\n\t\t\taccount.unlink(Versus.VersusAdminPublicPath)\n\t\t\tdestroy <- account.load<@AnyResource>(from: Versus.VersusAdminStoragePath)\n\t\t}\n\t\t//create versus admin client\n\t\taccount.save(<- Versus.createAdminClient(), to:Versus.VersusAdminStoragePath)\n\t\taccount.link<&{Versus.AdminPublic}>(Versus.VersusAdminPublicPath, target: Versus.VersusAdminStoragePath)\n\n\n\t}\n}\n","versus1_check":"import Versus from 0xVersus\n\n//this transaction is run as the account that will host and own the marketplace to set up the \n//versusAdmin client and create the empty content and art collection\ntransaction() {\n\n    prepare(account: AuthAccount) {\n        \n        //create versus admin client\n        account.save(<- Versus.createAdminClient(), to:Versus.VersusAdminStoragePath)\n        account.link<&{Versus.AdminPublic}>(Versus.VersusAdminPublicPath, target: Versus.VersusAdminStoragePath)\n\n\n    }\n}\n","versus2":"\n\nimport Versus from 0xVersus\n\n//This transactions is run as the owner of the versus contract and links in the client\n//ownerAddress is the address that will host the marketplace\ntransaction(ownerAddress: Address) {\n\n    //versus account\n    prepare(account: AuthAccount) {\n\n        let owner= getAccount(ownerAddress)\n        let client= owner.getCapability<&{Versus.AdminPublic}>(Versus.VersusAdminPublicPath)\n                .borrow() ?? panic(\"Could not borrow admin client\")\n\n        let versusAdminCap=account.getCapability<&Versus.DropCollection>(Versus.CollectionPrivatePath)\n        client.addCapability(versusAdminCap)\n\n      \n\n    }\n}\n \n"},"scripts":{"check_account":"import FungibleToken from 0xFungibleToken\nimport Art from 0xArt\n\npub struct AddressStatus {\n\n  pub(set) var address:Address\n  pub(set) var balance: UFix64\n  pub(set) var art: [Art.ArtData]\n  init (_ address:Address) {\n    self.address=address\n    self.balance= 0.0\n    self.art= []\n  }\n}\n\n/*\n  This script will check an address and print out its FT, NFT and Versus resources\n */\npub fun main(address:Address) : AddressStatus {\n    // get the accounts' public address objects\n    let account = getAccount(address)\n    let status= AddressStatus(address)\n    \n    if let vault= account.getCapability(/public/flowTokenBalance).borrow<&{FungibleToken.Balance}>() {\n       status.balance=vault.balance\n    }\n\n    status.art= Art.getArt(address: address)\n    \n    return status\n\n}\n","check_admin":"//mainnnet\nimport Versus from 0xVersus\n\n/*\n  This script will check if an address has created an admin client\n */\npub fun main(account:Address) : Bool {\n    return getAccount(account).getCapability<&{Versus.AdminPublic}>(Versus.VersusAdminPublicPath).check()\n}\n \n \n \n","check_art":"import Art from 0xArt\n\n/*\n  This script will check an address and print out its FT, NFT and Versus resources\n */\npub fun main(bidder:Address) : Bool {\n   \n    return getAccount(bidder).getCapability<&{Art.CollectionPublic}>(Art.CollectionPublicPath).check()\n}\n \n \n \n","check_content":"import FungibleToken from 0xFungibleToken\nimport Art from 0xArt\n\n\n\n/*\n  This script will check an address and print out its FT, NFT and Versus resources\n */\npub fun main(address:Address) : { String: String}{\n    // get the accounts' public address objects\n    let account = getAccount(address)\n    let art= Art.getArt(address: address)\n\n\tlet dict : { String: String} = {}\n\tfor a in art {\n\t\tdict[a.cacheKey] = a.metadata.name.concat(\"-\").concat(a.metadata.artist)\n\t}\n    \n    return dict\n\n}\n","check_salepublic":"import Marketplace from 0xMarketplace\nimport Art from 0xArt\n\n/*\n  This script will check an address and print out its FT, NFT and Versus resources\n */\npub fun main(owner:Address, id: UInt64) {\n   \n    let account= getAccount(owner)\n    let marketplaceCap = account.getCapability<&{Marketplace.SalePublic}>(Marketplace.CollectionPublicPath)\n\n    let marketplace= marketplaceCap.borrow()!\n    let art=marketplace.listSaleItems()\n\n    log(art)\n}\n \n \n \n","check_unsettled_drop":"import Versus from 0xVersus\n\npub fun main(owner:Address) : UInt64? {\n  let account = getAccount(owner)\n  let versusCap=account.getCapability<&{Versus.PublicDrop}>(Versus.CollectionPublicPath)\n  if let versus = versusCap.borrow() {\n      let versusStatuses=versus.getAllStatuses()\n      for s in versusStatuses.keys {\n         let status = versusStatuses[s]!\n         if status.active == false && status.expired==true && status.settledAt == nil {\n           return status.dropId\n         } \n      } \n  }\n  return nil\n}\n","drop_art":"\nimport Versus from 0xVersus\n\npub fun main(dropID: UInt64) : String {\n\n    return Versus.getArtForDrop(dropID)!\n}\n","drop_status":"import Versus from 0xVersus\n//check the status of a drop\npub fun main(dropID: UInt64) : Versus.DropStatus {\n\n    return Versus.getDrop(dropID)!\n}\n","drop_status_emulator":"\nimport Versus from 0xVersus\n\n//fetch the drop status\npub fun main(dropID: UInt64) : Versus.DropStatus {\n\n    return Versus.getDrop(dropID)!\n}\n","drops":"\nimport Versus from 0xVersus\n\n/*\n  Script used to get the first active drop in a versus \n */\npub fun main() : [Versus.DropStatus] {\n\n    return Versus.getDrops()\n}\n","dutchAuctionBidStatus":"import DutchAuction from 0xDutchAuction\n//check the status of a dutch auction\npub fun main(address: Address) : [UInt64] {\n\n\tlet account=getAccount(address)\n\tlet bidCap=account.getCapability<&DutchAuction.BidCollection{DutchAuction.BidCollectionPublic}>(DutchAuction.BidCollectionPublicPath)\n\treturn bidCap.borrow()!.getIds()\n}\n","dutchAuctionBids":"import DutchAuction from 0xDutchAuction\n//check the status of a dutch auction\npub fun main(id: UInt64) : [DutchAuction.BidReport]{\n    return DutchAuction.getBids(id)\n}\n","dutchAuctionStatus":"import DutchAuction from 0xDutchAuction\n//check the status of a dutch auction\npub fun main(id: UInt64) : DutchAuction.DutchAuctionStatus {\n    return DutchAuction.getDutchAuction(id)!\n}\n","get_active_auction":"import Versus from 0xVersus\n\n/*\n  Script used to get the first active drop in a versus \n */\npub fun main() : Versus.DropStatus?{\n\n    return Versus.getActiveDrop()\n}\n","is_admin":"import Versus from 0xVersus\n/*\n  This script will check an address and print out its an admin\n *\npub fun main(address:Address) : Bool {\n\n    let account=getAccount(address)\n    let adminClient: Capability<&{Versus.AdminPublic}> =account.getCapability<&{Versus.AdminPublic}>(Versus.VersusAdminPublicPath) \n    return adminClient.check()\n\n}\n","not_valid_drop":"import Versus from 0xVersus\n//check the status of a drop\npub fun main(dropID: UInt64) : Bool {\n\n    let drop= Versus.getDrop(dropID)\n\tif drop == nil {\n\t\treturn false\n\t}\n\n    if drop?.active == false && drop?.settledAt == nil {\n\t\treturn true\n\t}\n\treturn false\n\n}\n","profile":"import Profile from 0xProfile\npub fun main(address:Address) : &<Profile.UserProfile? {\n  return getAccount(address)\n        .getCapability<&{Profile.Public}>(Profile.publicPath)\n        .borrow()?.asProfile()\n}\n","test":"pub fun bubbleSort(_ list: [BidInfo]) : [BidInfo]{\n\tvar changed=true\n\twhile changed {\n\t\tchanged=false\n\t\tvar index=0\n\t\twhile index < list.length-1 {\n\t\t\tvar curr = list[index]\n\t\t\tvar next= list[index+1]\n\n\t\t\t//the current item has lower price or same price and higher id.\n\t\t\tif curr.balance < next.balance || next.balance==curr.balance && curr.id > next.id {\n\t\t\t\tlist[index]=next\n\t\t\t\tlist[index+1]=curr\n\t\t\t\tchanged=true\n\t\t\t}\n\t\t\tindex=index+1\n\t\t}\n\t}\n\treturn list\n}\n\npub fun insertBid(items: [BidInfo], new: BidInfo) : [BidInfo]{\n\n\tfun inner(items: [BidInfo], new: BidInfo, lo: Int, hi:Int) : Int {\n\t\tvar high=hi\n\t\tvar low=lo\n\t\twhile low < high {\n\t\t\tlet mid =(low+high)/2\n\t\t\tlet midBid=items[mid]\n\t\t\tif midBid.balance < new.balance || midBid.balance==new.balance && midBid.id > new.id {\n\t\t\t\thigh=mid\n\t\t\t} else {\n\t\t\t\tlow=mid+1\n\t\t\t}\n\t\t}\n\t\treturn low\n\t}\n\n\tlet index= inner(items: items, new:new, lo:0, hi: items.length)\n\titems.insert(at: index, new)\n\treturn items\n}\n\npub struct BidInfo{\n\n\tpub let balance: UFix64\n\tpub let id: UInt64\n\tpub let desc:String\n\n\tinit(balance:UFix64, id: UInt64, desc:String) {\n\t\tself.balance =balance\n\t\tself.id=id\n\t\tself.desc=desc\n\t}\n}\n\n\npub fun main() {\n\n\tvar bids :[BidInfo] = [BidInfo(balance: 1.0, id:2, desc:\"1\"), BidInfo(balance: 1.0, id:3, desc:\"1\"), BidInfo(balance: 0.9, id:4, desc:\"1\" )]\n\n\tlog(bids)\n\n\tbids= insertBid(items: bids, new: BidInfo(balance: 1.0 , id:3, desc:\"BOO\"))\n\tlog(bids)\n\n}\n"},"vars":{"emulator":{"0xNonFungibleToken":"0xf8d6e0586b0a20c7","0xFungibleToken":"0xee82856bf20e2aa6","0xFlowToken":"0x0ae53cb6e3f42a79","0xFUSD":"0xf8d6e0586b0a20c7","0xContent":"0xf8d6e0586b0a20c7","0xDutchAuction":"0xf8d6e0586b0a20c7","0xArt":"0xf8d6e0586b0a20c7","0xAuction":"0xf8d6e0586b0a20c7","0xVersus":"0xf8d6e0586b0a20c7","0xMarketplace":"0xf8d6e0586b0a20c7","0xProfile":"0xf8d6e0586b0a20c7","0xDebug":"0xf8d6e0586b0a20c7","0xClock":"0xf8d6e0586b0a20c7"},"testnet":{"0xNonFungibleToken":"0x631e88ae7f1d7c20","0xFungibleToken":"0x9a0766d93b6608b7","0xFlowToken":"0x7e60df042a9c0868","0xFUSD":"0xe223d8a629e49c68","0xContent":"0x99ca04281098b33d","0xDutchAuction":"0x99ca04281098b33d","0xArt":"0x99ca04281098b33d","0xAuction":"0x99ca04281098b33d","0xVersus":"0x99ca04281098b33d","0xMarketplace":"0x99ca04281098b33d","0xProfile":"0x99ca04281098b33d","0xDebug":"0x99ca04281098b33d","0xClock":"0x99ca04281098b33d"},"mainnet":{"0xNonFungibleToken":"0x1d7e57aa55817448","0xFungibleToken":"0xf233dcee88fe0abe","0xFlowToken":"0x1654653399040a61","0xFUSD":"0x3c5959b568896393","0xContent":"0xd796ff17107bbff6","0xDutchAuction":"0xd796ff17107bbff6","0xArt":"0xd796ff17107bbff6","0xAuction":"0xd796ff17107bbff6","0xVersus":"0xd796ff17107bbff6","0xMarketplace":"0xd796ff17107bbff6","0xProfile":"0xd796ff17107bbff6","0xDebug":"0xd796ff17107bbff6","0xClock":"0xd796ff17107bbff6"}}}