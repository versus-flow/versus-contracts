{"transactions":{"art_collection":"\nimport NonFungibleToken from 0xNonFungibleToken\nimport Art from 0xArt\n\n//This transaction will prepare the art collection\ntransaction() {\n    prepare(account: AuthAccount) {\n        account.save<@NonFungibleToken.Collection>(<- Art.createEmptyCollection(), to: Art.CollectionStoragePath)\n        account.link<&{Art.CollectionPublic}>(Art.CollectionPublicPath, target: Art.CollectionStoragePath)\n    }\n\n}\n\n","bid":"import FungibleToken from 0xFungibleToken\nimport NonFungibleToken from 0xNonFungibleToken\nimport Versus from 0xVersus\nimport Art from 0xArt\n\n// Transaction to make a bid in a marketplace for the given dropId and auctionId\ntransaction(marketplace: Address, dropId: UInt64, auctionId: UInt64, bidAmount: UFix64) {\n    // reference to the buyer's NFT collection where they\n    // will store the bought NFT\n\n    let vaultCap: Capability<&{FungibleToken.Receiver}>\n    let collectionCap: Capability<&{Art.CollectionPublic}> \n    let versusCap: Capability<&{Versus.PublicDrop}>\n    let temporaryVault: @FungibleToken.Vault\n\n    prepare(account: AuthAccount) {\n\n        // get the references to the buyer's Vault and NFT Collection receiver\n        var collectionCap = account.getCapability<&{Art.CollectionPublic}>(Art.CollectionPublicPath)\n\n        // if collection is not created yet we make it.\n        if !collectionCap.check() {\n            // store an empty NFT Collection in account storage\n            account.save<@NonFungibleToken.Collection>(<- Art.createEmptyCollection(), to: Art.CollectionStoragePath)\n\n            // publish a capability to the Collection in storage\n            account.link<&{Art.CollectionPublic}>(Art.CollectionPublicPath, target: Art.CollectionStoragePath)\n        }\n\n        self.collectionCap=collectionCap\n        \n        self.vaultCap = account.getCapability<&{FungibleToken.Receiver}>(/public/flowTokenReceiver)\n                   \n        let vaultRef = account.borrow<&FungibleToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Could not borrow owner's Vault reference\")\n\n        let seller = getAccount(marketplace)\n        self.versusCap = seller.getCapability<&{Versus.PublicDrop}>(Versus.CollectionPublicPath)\n        let currentBid=self.versusCap.borrow()!.currentBidForUser(dropId: dropId, auctionId: auctionId, address: account.address)\n        //if your capability is the leader you only have to send in the difference\n\n        // withdraw tokens from the buyer's Vault\n        self.temporaryVault <- vaultRef.withdraw(amount: bidAmount - currentBid)\n    }\n\n    execute {\n        self.versusCap.borrow()!.placeBid(dropId: dropId, auctionId: auctionId, bidTokens: <- self.temporaryVault, vaultCap: self.vaultCap, collectionCap: self.collectionCap)\n    }\n}\n \n","destroy_content":"import Versus from 0xVersus\n//This transaction will destroy a versus drop using the admin client\ntransaction(id: UInt64) {\n    let client: &Versus.Admin\n    prepare(account: AuthAccount) {\n        self.client = account.borrow<&Versus.Admin>(from: Versus.VersusAdminStoragePath) ?? panic(\"could not load versus admin\")\n    }\n\n    execute {\n        let contentCollection=self.client.getContent()\n\t\tlet drop <- dropCollection.drops[id]  <- nil\n\t\tdestroy drop\n\t}\n  }\n\n","destroy_versus":"import Versus from 0xVersus\n//This transaction will destroy a versus drop using the admin client\ntransaction(id: UInt64) {\n    let client: &Versus.Admin\n    prepare(account: AuthAccount) {\n        self.client = account.borrow<&Versus.Admin>(from: Versus.VersusAdminStoragePath) ?? panic(\"could not load versus admin\")\n    }\n\n    execute {\n        let dropCollection=self.client.getDropCollection()\n\t\tlet drop <- dropCollection.drops[id]  <- nil\n\t\tdestroy drop\n\t}\n  }\n\n","drop":"import FungibleToken from 0xFungibleToken\nimport NonFungibleToken from 0xNonFungibleToken\nimport Versus from 0xVersus\n\n//This transaction will setup a drop in a versus auction\ntransaction(\n    artist: Address, \n    startPrice: UFix64, \n    startTime: UFix64,\n    artistName: String, \n    artName: String,\n    description: String, \n    editions: UInt64,\n    minimumBidIncrement: UFix64, \n    minimumBidUniqueIncrement:UFix64,\n    duration:UFix64,\n    extensionOnLateBid:UFix64,\n    ) {\n\n\n    let client: &Versus.Admin\n    let artistWallet: Capability<&{FungibleToken.Receiver}>\n    let content: String\n\n    prepare(account: AuthAccount) {\n\n        let path = /storage/upload\n        self.content= account.load<String>(from: path) ?? panic(\"could not load content\")\n        self.client = account.borrow<&Versus.Admin>(from: Versus.VersusAdminStoragePath) ?? panic(\"could not load versus admin\")\n        self.artistWallet=  getAccount(artist).getCapability<&{FungibleToken.Receiver}>(/public/flowTokenReceiver)\n    }\n    \n    execute {\n\n        let art <-  self.client.mintArt(\n            artist: artist,\n            artistName: artistName,\n            artName: artName,\n            content:self.content,\n            description: description)\n\n        self.client.createDrop(\n           nft:  <- art,\n           editions: editions,\n           minimumBidIncrement: minimumBidIncrement,\n           minimumBidUniqueIncrement: minimumBidUniqueIncrement,\n           startTime: startTime,\n           startPrice: startPrice,\n           vaultCap: self.artistWallet,\n           duration: duration,\n           extensionOnLateBid: extensionOnLateBid \n       )\n    }\n}\n\n\n","marketplace":"import Art from 0xArt\nimport Marketplace from 0xMarketplace\nimport FungibleToken from 0xFungibleToken\nimport NonFungibleToken from 0xNonFungibleToken\n\n//Transaction to make a bid in a marketplace for the given dropId and auctionId\ntransaction(marketplace: Address, tokenId: UInt64, amount: UFix64) {\n    // reference to the buyer's NFT collection where they\n    // will store the bought NFT\n\n    let vaultCap: Capability<&{FungibleToken.Receiver}>\n    let collectionCap: Capability<&{Art.CollectionPublic}> \n    // Vault that will hold the tokens that will be used\n    // to buy the NFT\n    let temporaryVault: @FungibleToken.Vault\n\n    prepare(account: AuthAccount) {\n\n        // get the references to the buyer's Vault and NFT Collection receiver\n        var collectionCap = account.getCapability<&{Art.CollectionPublic}>(Art.CollectionPublicPath)\n\n        // if collection is not created yet we make it.\n        if !collectionCap.check() {\n            // store an empty NFT Collection in account storage\n            account.save<@NonFungibleToken.Collection>(<- Art.createEmptyCollection(), to: Art.CollectionStoragePath)\n\n            // publish a capability to the Collection in storage\n            account.link<&{Art.CollectionPublic}>(Art.CollectionPublicPath, target: Art.CollectionStoragePath)\n        }\n\n        self.collectionCap=collectionCap\n        \n        self.vaultCap = account.getCapability<&{FungibleToken.Receiver}>(/public/flowTokenReceiver)\n                   \n        let vaultRef = account.borrow<&FungibleToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Could not borrow owner's Vault reference\")\n\n        // withdraw tokens from the buyer's Vault\n        self.temporaryVault <- vaultRef.withdraw(amount: amount)\n    }\n\n    execute {\n        // get the read-only account storage of the seller\n        let seller = getAccount(marketplace)\n\n        let marketplace= seller.getCapability(Marketplace.CollectionPublicPath).borrow<&{Marketplace.SalePublic}>()\n                         ?? panic(\"Could not borrow seller's sale reference\")\n\n        marketplace.purchase(tokenID: tokenId, recipientCap:self.collectionCap, buyTokens: <- self.temporaryVault)\n    }\n}\n \n","mint_art":"\nimport Versus from 0xVersus\nimport Art from 0xArt\n\n//mint an art and add it to a users collection\ntransaction(\n    artist: Address,\n    artistName: String, \n    artName: String, \n    description: String) {\n\n    let artistCollection: Capability<&{Art.CollectionPublic}>\n    let client: &Versus.Admin\n\t\tlet content: String\n\n    prepare(account: AuthAccount) {\n        let path = /storage/upload\n        self.content= account.load<String>(from: path) ?? panic(\"could not load content\")\n \n        self.client = account.borrow<&Versus.Admin>(from: Versus.VersusAdminStoragePath) ?? panic(\"could not load versus admin\")\n        self.artistCollection= getAccount(artist).getCapability<&{Art.CollectionPublic}>(Art.CollectionPublicPath)\n    }\n\n    execute {\n        let art <-  self.client.mintArt(artist: artist, artistName: artistName, artName: artName, content:self.content, description: description)\n        self.artistCollection.borrow()!.deposit(token: <- art)\n    }\n}\n\n","mint_art_e":"import Versus from 0xVersus\n\n//Transaction to mint Art and edition art and deploy to all addresses\ntransaction(\n    artist: Address,\n    artistName: String, \n    artName: String, \n    description: String,\n    addresses: [Address]) {\n\n    let client: &Versus.Admin\n    let content: String\n\n    prepare(account: AuthAccount) {\n\n        let path = /storage/upload\n        self.content= account.load<String>(from: path) ?? panic(\"could not load content\")\n        self.client = account.borrow<&Versus.Admin>(from: Versus.VersusAdminStoragePath) ?? panic(\"could not load versus admin\")\n    }\n\n    execute {\n        let art <-  self.client.mintArt(artist: artist, artistName: artistName, artName: artName, content:self.content, description: description)\n        self.client.editionAndDepositArt(art: &art as &Art.NFT, to: addresses)\n        destroy art\n    }\n}\n\n","mint_edition":"import NonFungibleToken from 0xNonFungibleToken\nimport Art from 0xArt\nimport Versus from 0xVersus\n\n//transaction to create an edition of an nft in admins collection and send it to a user\ntransaction(\n    user: Address,\n    original:Address,\n    artId: UInt64,\n    edition: UInt64,\n    maxEdition: UInt64) {\n\n    let client: &Versus.Admin\n    let nftCollection: &NonFungibleToken.Collection\n    prepare(account: AuthAccount) {\n        self.client = account.borrow<&Versus.Admin>(from: Versus.VersusAdminStoragePath) ?? panic(\"could not load versus admin\")\n        self.nftCollection =account.borrow<&NonFungibleToken.Collection>(from: Art.CollectionStoragePath)!\n    }\n\n    execute {\n\n          let art <- self.nftCollection.withdraw(withdrawID: artId) as! @Art.NFT\n          let newArt <- self.client.editionArt(art: &art as &Art.NFT, edition:edition, maxEdition:maxEdition)\n\n          let userCollection : &{Art.CollectionPublic} = getAccount(user).getCapability<&{Art.CollectionPublic}>(Art.CollectionPublicPath).borrow()!\n          userCollection.deposit(token: <- newArt)\n\n          let originalCollection : &{Art.CollectionPublic} = getAccount(original).getCapability<&{Art.CollectionPublic}>(Art.CollectionPublicPath).borrow()!\n          originalCollection.deposit(token: <- art)\n    }\n}\n\n","mint_tokens":"\nimport FungibleToken from 0xFungibleToken\nimport FlowToken from 0xFlowToken\n\ntransaction(recipient: Address, amount: UFix64) {\n    let tokenAdmin: &FlowToken.Administrator\n    let tokenReceiver: &{FungibleToken.Receiver}\n\n    prepare(signer: AuthAccount) {\n\n        self.tokenAdmin = signer\n            .borrow<&FlowToken.Administrator>(from: /storage/flowTokenAdmin)\n            ?? panic(\"Signer is not the token admin\")\n\n        self.tokenReceiver = getAccount(recipient)\n            .getCapability(/public/flowTokenReceiver)\n            .borrow<&{FungibleToken.Receiver}>()\n            ?? panic(\"Unable to borrow receiver reference\")\n    }\n\n    execute {\n        let minter <- self.tokenAdmin.createNewMinter(allowedAmount: amount)\n        let mintedVault <- minter.mintTokens(amount: amount)\n\n        self.tokenReceiver.deposit(from: <-mintedVault)\n\n        destroy minter\n    }\n}\n","move_art":"\nimport NonFungibleToken from 0xNonFungibleToken\nimport Art from 0xArt\n\n//Transaction to move a NFT art from the signers collection to another collection\ntransaction(address:Address, artID: UInt64) {\n\n  let nftCollection: &NonFungibleToken.Collection\n\n  prepare(account: AuthAccount) {\n    self.nftCollection =account.borrow<&NonFungibleToken.Collection>(from: Art.CollectionStoragePath)!\n  }\n\n  execute {\n      let versusCollection : &{Art.CollectionPublic} = getAccount(address).getCapability<&{Art.CollectionPublic}>(Art.CollectionPublicPath).borrow()!\n      let art <- self.nftCollection.withdraw(withdrawID:artID)\n      versusCollection.deposit(token: <- art)\n  }\n}\n","profile":"import FungibleToken from 0xFungibleToken\nimport FUSD from 0xFUSD\nimport FlowToken from 0xFlowToken\nimport NonFungibleToken from 0xNonFungibleToken\nimport Art from 0xArt\nimport Versus from 0xVersus\nimport Profile from 0xProfile\nimport Marketplace from 0xMarketplace\n\ntransaction(name: String, description: String, allowStoringFollowers: Bool) {\n  prepare(acct: AuthAccount) {\n\n    let profile <-Profile.createUser(name:name, description: description, allowStoringFollowers:allowStoringFollowers, tags:[\"versus\"])\n\n    //adding existing flowToken wallet\n    let flowReceiver= acct.getCapability<&{FungibleToken.Receiver}>(/public/flowTokenReceiver)\n    let flowBalance= acct.getCapability<&{FungibleToken.Balance}>(/public/flowTokenBalance)\n    let flow=acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)!\n    let flowWallet= Profile.Wallet(name:\"Flow\", receiver: flowReceiver, balance: flowBalance, accept:flow.getType(), tags: [\"flow\"])\n    profile.addWallet(flowWallet)\n\n\n    //Add exising FUSD or create a new one and add it\n    let fusdReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/fusdReceiver)\n    if !fusdReceiver.check() {\n      let fusd <- FUSD.createEmptyVault()\n      let fusdType=fusd.getType()\n      acct.save(<- fusd, to: /storage/fusdVault)\n      acct.link<&FUSD.Vault{FungibleToken.Receiver}>( /public/fusdReceiver, target: /storage/fusdVault)\n      acct.link<&FUSD.Vault{FungibleToken.Balance}>( /public/fusdBalance, target: /storage/fusdVault)\n    }\n    let fusdWallet=Profile.Wallet(\n        name:\"FUSD\", \n        receiver:fusdReceiver,\n        balance:acct.getCapability<&{FungibleToken.Balance}>(/public/fusdBalance),\n        accept: fusdType,\n        tags: [\"fusd\", \"stablecoin\"]\n    )\n    profile.addWallet(fusdWallet)\n\n\n    //Create versus art collection if it does not exist and add it\n    let artCollectionCap=acct.getCapability<&{Art.CollectionPublic}>(Art.CollectionPublicPath)\n    if !artCollectionCap.check() {\n      acct.save<@NonFungibleToken.Collection>(<- Art.createEmptyCollection(), to: Art.CollectionStoragePath)\n      acct.link<&{Art.CollectionPublic}>(Art.CollectionPublicPath, target: Art.CollectionStoragePath)\n    }\n    profile.addCollection(Profile.ResourceCollection( \n        name: \"VersusArt\", \n        collection:artCollectionCap, \n        type: Type<&{Art.CollectionPublic}>(),\n        tags: [\"versus\", \"nft\"]))\n\n    let marketplaceCap = acct.getCapability<&{Marketplace.SalePublic}>(Marketplace.CollectionPublicPath)\n    if !marketplaceCap.check() {\n      let sale <- Marketplace.createSaleCollection(ownerVault: flowReceiver)\n      acct.save<@Marketplace.SaleCollection>(<- sale, to:Marketplace.CollectionStoragePath)\n      acct.link<&{Marketplace.SalePublic}>(Marketplace.CollectionPublicPath, target: Marketplace.CollectionStoragePath)\n    }\n    profile.addCollection(Profile.ResourceCollection(\n        \"VersusMarketplace\", \n        marketplaceCap, \n        Type<&{Marketplace.SalePublic}>(),\n        [\"versus\", \"marketplace\"]))\n\n\n    acct.save(<-profile, to: Profile.storagePath)\n    acct.link<&Profile.User{Profile.Public}>(Profile.publicPath, target: Profile.storagePath)\n  }\n}\n\n","settle":"import Versus from 0xVersus\n\n//Transaction to settle/finish off an auction. Has to be signed by the owner of the versus marketplace\ntransaction(dropId: UInt64) {\n\n    let client: &Versus.Admin\n    prepare(account: AuthAccount) {\n        self.client = account.borrow<&Versus.Admin>(from: Versus.VersusAdminStoragePath) ?? panic(\"could not load versus admin\")\n    }\n\n    execute {\n        self.client.settle(dropId)\n    }\n}\n \n","setup_marketplace_with_art":"import Marketplace from 0xMarketplace\nimport Art from 0xArt\nimport FungibleToken from 0xFungibleToken\n\n//this transaction will setup an newly minted item for sale\ntransaction(\n    artId: UInt64\n    price: UFix64) {\n\n    let artCollection:&Art.Collection\n    let marketplace: &Marketplace.SaleCollection\n\n    prepare(account: AuthAccount) {\n\n\n        let marketplaceCap = account.getCapability<&{Marketplace.SalePublic}>(Marketplace.CollectionPublicPath)\n        // if sale collection is not created yet we make it.\n        if !marketplaceCap.check() {\n             let wallet=  account.getCapability<&{FungibleToken.Receiver}>(/public/flowTokenReceiver)\n             let sale <- Marketplace.createSaleCollection(ownerVault: wallet)\n\n            // store an empty NFT Collection in account storage\n            account.save<@Marketplace.SaleCollection>(<- sale, to:Marketplace.CollectionStoragePath)\n\n            // publish a capability to the Collection in storage\n            account.link<&{Marketplace.SalePublic}>(Marketplace.CollectionPublicPath, target: Marketplace.CollectionStoragePath)\n        }\n\n        self.marketplace=account.borrow<&Marketplace.SaleCollection>(from: Marketplace.CollectionStoragePath)!\n        self.artCollection= account.borrow<&Art.Collection>(from: Art.CollectionStoragePath)!\n    }\n\n    execute {\n        let art <- self.artCollection.withdraw(withdrawID: artId) as! @Art.NFT\n        self.marketplace.listForSale(token: <- art, price: 5.0)\n        self.marketplace.changePrice(tokenID: artId, newPrice: price)\n    }\n}\n\n","tick":"import Versus from 0xVersus\n\n/*\nSimulate that the clock is running\n */\ntransaction(dropID: UInt64) {\n    prepare(account: AuthAccount) {    \n      let block=getCurrentBlock()\n      if let versus = account.getCapability(Versus.CollectionPublicPath).borrow<&{Versus.PublicDrop}>() {\n          let versusStatus=versus.getStatus(dropId: dropID)\n          log(\"currentBlock=\".concat(block.height.toString()).concat( \" currentTime=\").concat(block.timestamp.toString()).concat( \" endTime=\").concat(versusStatus.endTime.toString()).concat(\" timeRemaining=\").concat(versusStatus.timeRemaining.toString()))\n      }\n  }\n}\n","transfer_flow":"import FungibleToken from 0xFungibleToken\nimport FlowToken from 0xFlowToken\n\n//This transactions transfers flow on testnet from one account to another\ntransaction(amount: UFix64, to: Address) {\n  let sentVault: @FungibleToken.Vault\n\n  prepare(signer: AuthAccount) {\n\n    let vaultRef = signer.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n      ?? panic(\"Could not borrow reference to the owner's Vault!\")\n\n    self.sentVault <- vaultRef.withdraw(amount: amount)\n  }\n\n  execute {\n    let recipient = getAccount(to)\n\n    let receiverRef = recipient.getCapability(/public/flowTokenReceiver)!.borrow<&{FungibleToken.Receiver}>()\n      ?? panic(\"Could not borrow receiver reference to the recipient's Vault\")\n\n    receiverRef.deposit(from: <-self.sentVault)\n  }\n}\n","transfer_flow_versus":"import FungibleToken from 0xFungibleToken\nimport FlowToken from 0xFlowToken\nimport Versus from 0xVersus\n\n//This transactions transfers flow on from versus to another user\ntransaction(amount: UFix64, to: Address) {\n  let sentVault: @FungibleToken.Vault\n\n  prepare(signer: AuthAccount) {\n    let client = signer.borrow<&Versus.Admin>(from: Versus.VersusAdminStoragePath) ?? panic(\"could not load versus admin\")\n    self.sentVault <- client.getFlowWallet().withdraw(amount: amount)\n  }\n\n  execute {\n    let recipient = getAccount(to)\n    let receiverRef = recipient.getCapability(/public/flowTokenReceiver)!.borrow<&{FungibleToken.Receiver}>()\n      ?? panic(\"Could not borrow receiver reference to the recipient's Vault\")\n\n    receiverRef.deposit(from: <-self.sentVault)\n  }\n}\n","upload":"transaction(part: String) {\n    prepare(signer: AuthAccount) {\n        let path = /storage/upload\n        let existing = signer.load<String>(from: path) ?? \"\"\n        signer.save(existing.concat(part), to: path)\n    }\n}\n","versus1":"import FungibleToken from 0xFungibleToken\nimport NonFungibleToken from 0xNonFungibleToken\nimport Content from 0xContent\nimport Art from 0xArt\nimport Versus from 0xVersus\nimport Auction from 0xAuction\n\n//this transaction is run as the account that will host and own the marketplace to set up the \n//versusAdmin client and create the empty content and art collection\ntransaction() {\n\n    prepare(account: AuthAccount) {\n\n        \n        //create versus admin client\n        account.save(<- Versus.createAdminClient(), to:Versus.VersusAdminStoragePath)\n        account.link<&{Versus.AdminPublic}>(Versus.VersusAdminPublicPath, target: Versus.VersusAdminStoragePath)\n\n\n    }\n}\n","versus1_check":"import Versus from 0xVersus\n\n//this transaction is run as the account that will host and own the marketplace to set up the \n//versusAdmin client and create the empty content and art collection\ntransaction() {\n\n    prepare(account: AuthAccount) {\n        \n        //create versus admin client\n        account.save(<- Versus.createAdminClient(), to:Versus.VersusAdminStoragePath)\n        account.link<&{Versus.AdminPublic}>(Versus.VersusAdminPublicPath, target: Versus.VersusAdminStoragePath)\n\n\n    }\n}\n","versus2":"\n\nimport Versus from 0xVersus\n\n//This transactions is run as the owner of the versus contract and links in the client\n//ownerAddress is the address that will host the marketplace\ntransaction(ownerAddress: Address) {\n\n    //versus account\n    prepare(account: AuthAccount) {\n\n        let owner= getAccount(ownerAddress)\n        let client= owner.getCapability<&{Versus.AdminPublic}>(Versus.VersusAdminPublicPath)\n                .borrow() ?? panic(\"Could not borrow admin client\")\n\n        let versusAdminCap=account.getCapability<&Versus.DropCollection>(Versus.CollectionPrivatePath)\n        client.addCapability(versusAdminCap)\n\n      \n\n    }\n}\n \n"},"scripts":{"check_account":"import FungibleToken from 0xFungibleToken\nimport Art from 0xArt\n\npub struct AddressStatus {\n\n  pub(set) var address:Address\n  pub(set) var balance: UFix64\n  pub(set) var art: [Art.ArtData]\n  init (_ address:Address) {\n    self.address=address\n    self.balance= 0.0\n    self.art= []\n  }\n}\n\n/*\n  This script will check an address and print out its FT, NFT and Versus resources\n */\npub fun main(address:Address) : AddressStatus {\n    // get the accounts' public address objects\n    let account = getAccount(address)\n    let status= AddressStatus(address)\n    \n    if let vault= account.getCapability(/public/flowTokenBalance).borrow<&{FungibleToken.Balance}>() {\n       status.balance=vault.balance\n    }\n\n    status.art= Art.getArt(address: address)\n    \n    return status\n\n}\n","check_admin":"//mainnnet\nimport Versus from 0xVersus\n\n/*\n  This script will check if an address has created an admin client\n */\npub fun main(account:Address) : Bool {\n    return getAccount(account).getCapability<&{Versus.AdminPublic}>(Versus.VersusAdminPublicPath).check()\n}\n \n \n \n","check_art":"import Art from 0xArt\n\n/*\n  This script will check an address and print out its FT, NFT and Versus resources\n */\npub fun main(bidder:Address) : Bool {\n   \n    return getAccount(bidder).getCapability<&{Art.CollectionPublic}>(Art.CollectionPublicPath).check()\n}\n \n \n \n","check_content":"import FungibleToken from 0xFungibleToken\nimport Art from 0xArt\n\n\n\n/*\n  This script will check an address and print out its FT, NFT and Versus resources\n */\npub fun main(address:Address) : { String: String}{\n    // get the accounts' public address objects\n    let account = getAccount(address)\n    let art= Art.getArt(address: address)\n\n\tlet dict : { String: String} = {}\n\tfor a in art {\n\t\tdict[a.cacheKey] = a.metadata.name.concat(\"-\").concat(a.metadata.artist)\n\t}\n    \n    return dict\n\n}\n","check_salepublic":"import Marketplace from 0xMarketplace\nimport Art from 0xArt\n\n/*\n  This script will check an address and print out its FT, NFT and Versus resources\n */\npub fun main(owner:Address, id: UInt64) {\n   \n    let account= getAccount(owner)\n    let marketplaceCap = account.getCapability<&{Marketplace.SalePublic}>(Marketplace.CollectionPublicPath)\n\n    let marketplace= marketplaceCap.borrow()!\n    let art=marketplace.listSaleItems()\n\n    log(art)\n}\n \n \n \n","check_unsettled_drop":"import Versus from 0xVersus\n\npub fun main(owner:Address) : UInt64? {\n  let account = getAccount(owner)\n  let versusCap=account.getCapability<&{Versus.PublicDrop}>(Versus.CollectionPublicPath)\n  if let versus = versusCap.borrow() {\n      let versusStatuses=versus.getAllStatuses()\n      for s in versusStatuses.keys {\n         let status = versusStatuses[s]!\n         if status.active == false && status.expired==true && status.settledAt == nil {\n           return status.dropId\n         } \n      } \n  }\n  return nil\n}\n","drop_art":"\nimport Versus from 0xVersus\n\npub fun main(dropID: UInt64) : String {\n\n    return Versus.getArtForDrop(dropID)!\n}\n","drop_status":"import Versus from 0xVersus\n//check the status of a drop\npub fun main(dropID: UInt64) : Versus.DropStatus {\n\n    return Versus.getDrop(dropID)!\n}\n","drop_status_emulator":"\nimport Versus from 0xVersus\n\n//fetch the drop status\npub fun main(dropID: UInt64) : Versus.DropStatus {\n\n    return Versus.getDrop(dropID)!\n}\n","drops":"\nimport Versus from 0xVersus\n\n/*\n  Script used to get the first active drop in a versus \n */\npub fun main() : [Versus.DropStatus] {\n\n    return Versus.getDrops()\n}\n","get_active_auction":"import Versus from 0xVersus\n\n/*\n  Script used to get the first active drop in a versus \n */\npub fun main() : Versus.DropStatus?{\n\n    return Versus.getActiveDrop()\n}\n","is_admin":"import Versus from 0xVersus\n/*\n  This script will check an address and print out its an admin\n *\npub fun main(address:Address) : Bool {\n\n    let account=getAccount(address)\n    let adminClient: Capability<&{Versus.AdminPublic}> =account.getCapability<&{Versus.AdminPublic}>(Versus.VersusAdminPublicPath) \n    return adminClient.check()\n\n}\n","not_valid_drop":"import Versus from 0xVersus\n//check the status of a drop\npub fun main(dropID: UInt64) : Bool {\n\n    let drop= Versus.getDrop(dropID)\n\tif drop == nil {\n\t\treturn false\n\t}\n\n    if drop?.active == false && drop?.settledAt == nil {\n\t\treturn true\n\t}\n\treturn false\n\n}\n","profile":"import Profile from 0xProfile\npub fun main(address:Address) : &<Profile.UserProfile? {\n  return getAccount(address)\n        .getCapability<&{Profile.Public}>(Profile.publicPath)\n        .borrow()?.asProfile()\n}\n"},"vars":{"emulator":{"0xNonFungibleToken":"0xf8d6e0586b0a20c7","0xFungibleToken":"0xee82856bf20e2aa6","0xFlowToken":"0x0ae53cb6e3f42a79","0xFUSD":"0xf8d6e0586b0a20c7","0xContent":"0xf8d6e0586b0a20c7","0xArt":"0xf8d6e0586b0a20c7","0xAuction":"0xf8d6e0586b0a20c7","0xVersus":"0xf8d6e0586b0a20c7","0xMarketplace":"0xf8d6e0586b0a20c7","0xProfile":"0xf8d6e0586b0a20c7"},"testnet":{"0xNonFungibleToken":"0x631e88ae7f1d7c20","0xFungibleToken":"0x9a0766d93b6608b7","0xFlowToken":"0x7e60df042a9c0868","0xFUSD":"0xe223d8a629e49c68","0xContent":"0x99ca04281098b33d","0xArt":"0x99ca04281098b33d","0xAuction":"0x99ca04281098b33d","0xVersus":"0x99ca04281098b33d","0xMarketplace":"0x99ca04281098b33d","0xProfile":"0x99ca04281098b33d"},"mainnet":{"0xNonFungibleToken":"0x1d7e57aa55817448","0xFungibleToken":"0xf233dcee88fe0abe","0xFlowToken":"0x1654653399040a61","0xFUSD":"0x3c5959b568896393","0xContent":"0xd796ff17107bbff6","0xArt":"0xd796ff17107bbff6","0xAuction":"0xd796ff17107bbff6","0xVersus":"0xd796ff17107bbff6","0xMarketplace":"0xd796ff17107bbff6","0xProfile":"0xd796ff17107bbff6"}}}